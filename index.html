<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Selfie Segmentation with Image / Video Overlay</title>

  <!-- MediaPipe Scripts -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js" crossorigin="anonymous"></script>

  <style>
    body {
      margin: 0;
      background: #000;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #fff;
      overflow: hidden;
    }

    .container {
      position: relative;
      width: 100vw;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .input_video {
      position: absolute;
      display: none;
    }

    #output_canvas {
      position: absolute;
      max-width: 100%;
      max-height: 100%;
    }

    /* コントロールパネル */
    #controlPanel {
      position: fixed;
      top: 16px;
      left: 16px;
      z-index: 10;
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    /* ファイル入力は隠す */
    #bgInput,
    #videoInput {
      display: none;
    }

    /* ファイル選択ボタン（画像／動画共通） */
    .btn-select {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      padding: 8px 12px;
      border-radius: 999px;
      border: none;
      background: rgba(128, 128, 128, 0.6); /* グレー半透明 */
      color: #ffffff; /* 白文字 */
      font-size: 13px;
      cursor: pointer;
      backdrop-filter: blur(4px);
      user-select: none;
      text-decoration: none;
    }

    .btn-select svg {
      width: 16px;
      height: 16px;
      fill: #ffffff;
    }

    .btn-select:active {
      transform: translateY(1px);
      opacity: 0.9;
    }

    .status {
      font-size: 11px;
      opacity: 0.85;
      margin-left: 4px;
      min-width: 180px;
    }

    /* モードトグル */
    .mode-toggle {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      margin-left: 4px;
      padding: 4px;
      border-radius: 999px;
      background: rgba(40, 40, 40, 0.7);
      backdrop-filter: blur(4px);
    }

    .mode-btn {
      width: 32px;
      height: 32px;
      border-radius: 999px;
      border: none;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      cursor: pointer;
      padding: 0;
    }

    .mode-btn svg {
      width: 18px;
      height: 18px;
      fill: #aaaaaa;
    }

    .mode-btn.active {
      background: rgba(220, 220, 220, 0.2);
    }

    .mode-btn.active svg {
      fill: #ffffff;
    }

    .mode-btn:active {
      transform: translateY(1px);
    }
  </style>
</head>

<body>
  <!-- コントロールエリア -->
  <div id="controlPanel">
    <!-- 画像ファイル選択 -->
    <label for="bgInput" class="btn-select">
      <!-- シンプルな写真アイコン（SVG） -->
      <svg viewBox="0 0 24 24">
        <rect x="3" y="5" width="18" height="14" rx="2" ry="2"></rect>
        <circle cx="9" cy="11" r="2.2"></circle>
        <path d="M14 11l3.5 4.5h-9L11 11l1.5 2z"></path>
      </svg>
      <span>Image</span>
    </label>
    <input type="file" id="bgInput" accept="image/*" />

    <!-- 動画ファイル選択 -->
    <label for="videoInput" class="btn-select">
      <!-- シンプルなフィルム／再生アイコン（SVG） -->
      <svg viewBox="0 0 24 24">
        <rect x="3" y="4" width="18" height="16" rx="2" ry="2"></rect>
        <path d="M10 9.5v5l4.5-2.5L10 9.5z"></path>
        <circle cx="6.5" cy="8" r="0.8"></circle>
        <circle cx="6.5" cy="12" r="0.8"></circle>
        <circle cx="6.5" cy="16" r="0.8"></circle>
      </svg>
      <span>Video</span>
    </label>
    <input type="file" id="videoInput" accept="video/*" />

    <!-- モードトグル -->
    <div class="mode-toggle" title="Overlay mode">
      <button id="modeImageBtn" class="mode-btn">
        <!-- アイコン：写真 -->
        <svg viewBox="0 0 24 24">
          <rect x="3" y="5" width="18" height="14" rx="2" ry="2"></rect>
          <circle cx="9" cy="11" r="2.2"></circle>
          <path d="M14 11l3.5 4.5h-9L11 11l1.5 2z"></path>
        </svg>
      </button>
      <button id="modeVideoBtn" class="mode-btn">
        <!-- アイコン：再生ボタン -->
        <svg viewBox="0 0 24 24">
          <circle cx="12" cy="12" r="9"></circle>
          <path d="M10 9v6l4.5-3L10 9z" fill="#000000"></path>
        </svg>
      </button>
    </div>

    <span id="overlayStatus" class="status">Overlay: Image mode / ファイル未読み込み</span>
  </div>

  <div class="container">
    <!-- Webカメラの映像を取得 -->
    <video class="input_video"></video>
    <!-- 出力用 Canvas -->
    <canvas id="output_canvas" width="1280" height="720"></canvas>
  </div>

  <script>
    let videoElement;
    let canvasElement;
    let canvasCtx;
    let selfieSegmentation;
    let camera;

    // 画像用
    let overlayImage = null;
    let overlayImageLoaded = false;

    // 動画用
    const overlayVideo = document.createElement('video');
    overlayVideo.style.display = 'none';
    overlayVideo.muted = true;
    overlayVideo.loop = true;
    overlayVideo.playsInline = true;
    overlayVideo.autoplay = true;
    document.body.appendChild(overlayVideo);

    let overlayVideoLoaded = false;

    const bgInput = document.getElementById('bgInput');
    const videoInput = document.getElementById('videoInput');
    const overlayStatus = document.getElementById('overlayStatus');

    const modeImageBtn = document.getElementById('modeImageBtn');
    const modeVideoBtn = document.getElementById('modeVideoBtn');

    // 'image' or 'video'
    let currentMode = 'image';

    function updateModeButtons() {
      if (currentMode === 'image') {
        modeImageBtn.classList.add('active');
        modeVideoBtn.classList.remove('active');
        if (overlayImageLoaded) {
          overlayStatus.textContent = 'Overlay: Image mode / 画像読み込み済み';
        } else {
          overlayStatus.textContent = 'Overlay: Image mode / ファイル未読み込み';
        }
      } else {
        modeImageBtn.classList.remove('active');
        modeVideoBtn.classList.add('active');
        if (overlayVideoLoaded) {
          overlayStatus.textContent = 'Overlay: Video mode / 動画読み込み済み';
        } else {
          overlayStatus.textContent = 'Overlay: Video mode / ファイル未読み込み';
        }
      }
    }

    // モードボタンクリック
    modeImageBtn.addEventListener('click', () => {
      currentMode = 'image';
      updateModeButtons();
    });

    modeVideoBtn.addEventListener('click', () => {
      currentMode = 'video';
      updateModeButtons();
    });

    // 画像読み込みヘルパー
    function setOverlayImageFromSrc(src) {
      overlayImageLoaded = false;
      const img = new Image();
      img.onload = () => {
        overlayImage = img;
        overlayImageLoaded = true;
        // 画像を読み込んだタイミングでモードをImageに
        currentMode = 'image';
        updateModeButtons();
      };
      img.onerror = () => {
        overlayImage = null;
        overlayImageLoaded = false;
        console.error('背景画像の読み込みに失敗しました');
        updateModeButtons();
      };
      img.src = src;
    }

    // 動画読み込みヘルパー
    function setOverlayVideoFromSrc(src) {
      overlayVideoLoaded = false;
      overlayVideo.src = src;
      overlayVideo.onloadedmetadata = () => {
        overlayVideoLoaded = true;
        overlayVideo.play().catch(err => console.warn('Video play error:', err));
        // 動画を読み込んだタイミングでモードをVideoに
        currentMode = 'video';
        updateModeButtons();
      };
      overlayVideo.onerror = () => {
        overlayVideoLoaded = false;
        console.error('動画の読み込みに失敗しました');
        updateModeButtons();
      };
    }

    // 画像ファイル選択
    bgInput.addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        setOverlayImageFromSrc(e.target.result); // data URL
      };
      reader.readAsDataURL(file);
    });

    // 動画ファイル選択
    videoInput.addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (!file) return;

      const url = URL.createObjectURL(file);
      setOverlayVideoFromSrc(url);
    });

    // Selfie Segmentation 結果コールバック
    function onResults(results) {
      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

      // segmentationMask を描画
      canvasCtx.drawImage(
        results.segmentationMask,
        0,
        0,
        canvasElement.width,
        canvasElement.height
      );

      // 人物部分のみ描画する
      canvasCtx.globalCompositeOperation = 'source-in';

      if (currentMode === 'image' && overlayImageLoaded && overlayImage) {
        // 画像モード
        canvasCtx.drawImage(
          overlayImage,
          0,
          0,
          canvasElement.width,
          canvasElement.height
        );
      } else if (currentMode === 'video' && overlayVideoLoaded) {
        // 動画モード（動画フレームをそのまま貼る）
        canvasCtx.drawImage(
          overlayVideo,
          0,
          0,
          canvasElement.width,
          canvasElement.height
        );
      } else {
        // どちらも未読み込みのときのフォールバック
        canvasCtx.fillStyle = '#444';
        canvasCtx.fillRect(0, 0, canvasElement.width, canvasElement.height);
      }

      // 背景部分に元の映像を描画
      canvasCtx.globalCompositeOperation = 'destination-atop';
      canvasCtx.drawImage(
        results.image,
        0,
        0,
        canvasElement.width,
        canvasElement.height
      );

      canvasCtx.restore();
    }

    window.onload = function () {
      videoElement = document.getElementsByClassName('input_video')[0];
      canvasElement = document.getElementById('output_canvas');
      canvasCtx = canvasElement.getContext('2d');

      // 初期モードは Image
      currentMode = 'image';
      updateModeButtons();

      // Selfie Segmentation 初期化
      selfieSegmentation = new SelfieSegmentation({
        locateFile: (file) => {
          return `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}`;
        }
      });

      selfieSegmentation.setOptions({
        modelSelection: 0, // 0: 一般モデル, 1: ランドスケープモデル
      });

      selfieSegmentation.onResults(onResults);

      // カメラ初期化
      camera = new Camera(videoElement, {
        onFrame: async () => {
          await selfieSegmentation.send({ image: videoElement });
        },
        width: 960,
        height: 520,
      });

      camera.start();
    };
  </script>
</body>

</html>
